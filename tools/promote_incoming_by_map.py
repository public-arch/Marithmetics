#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations
import re, sys
from pathlib import Path

INCOMING = Path("incoming")
DEMOS_DIR = Path("demos")
MAP_FILE = Path("tools/demo_map.yaml")

def parse_simple_yaml(path: Path) -> dict:
    """
    Minimal YAML reader for our tiny map format.
    Expects:
      demos:
        "36": {category: "cosmo", slug: "big-bang"}
    """
    txt = path.read_text(encoding="utf-8", errors="replace").splitlines()
    in_demos = False
    out = {}
    for line in txt:
        s = line.strip()
        if not s or s.startswith("#"):
            continue
        if s == "demos:":
            in_demos = True
            continue
        if not in_demos:
            continue
        # Match: "36": {category: "cosmo", slug: "x"}
        m = re.match(r'^"([^"]+)"\s*:\s*\{(.+)\}\s*$', s)
        if not m:
            continue
        key = m.group(1)
        inner = m.group(2)
        cat = re.search(r'category:\s*"([^"]+)"', inner)
        slug = re.search(r'slug:\s*"([^"]+)"', inner)
        if not (cat and slug):
            raise ValueError(f"Bad map line: {line}")
        out[key] = {"category": cat.group(1), "slug": slug.group(1)}
    return out

def ensure_init(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)
    init = p / "__init__.py"
    if not init.exists():
        init.write_text("# autogenerated\n", encoding="utf-8")

def find_py_for_demo(demo_key: str) -> Path | None:
    """
    demo_key is "36" or "66A"/"66B".
    For numeric demos: match demo-36-*.py OR DEMO-36*.py OR DEMO_36*.py
    For 66A/66B: pick two 66 candidates deterministically by name sort.
    """
    files = sorted([p for p in INCOMING.glob("*.py") if p.is_file()])
    if demo_key.isdigit():
        n = int(demo_key)
        pats = [
            re.compile(rf"^demo-{n:02d}-.*\.py$", re.IGNORECASE),
            re.compile(rf"^demo-{n}-.*\.py$", re.IGNORECASE),
            re.compile(rf"^DEMO[\-_ ]*0*{n}\b.*\.py$", re.IGNORECASE),
        ]
        for p in files:
            for pat in pats:
                if pat.match(p.name):
                    return p
        return None

    # Special-case 66A/66B
    if demo_key.startswith("66"):
        n = 66
        cand = []
        for p in files:
            if re.search(rf"\b{n}\b", p.name):
                cand.append(p)
        cand = sorted(cand, key=lambda x: x.name.lower())
        if len(cand) < 2:
            return cand[0] if cand else None
        return cand[0] if demo_key.endswith("A") else cand[1]

    return None

def find_readme_for_demo(demo_key: str) -> Path | None:
    """
    Look for README files in incoming that contain demo number in the filename:
      README-demo-36-*.md
      README_demo_36*.md
      README*.md with 36 inside
    For 66A/66B: pick two 66 README candidates by sort.
    """
    md_files = sorted([p for p in INCOMING.glob("*.md") if p.is_file()])
    if demo_key.isdigit():
        n = int(demo_key)
        pats = [
            re.compile(rf"^README[-_ ]*demo[-_ ]*{n:02d}\b.*\.md$", re.IGNORECASE),
            re.compile(rf"^README[-_ ]*demo[-_ ]*{n}\b.*\.md$", re.IGNORECASE),
            re.compile(rf"^README.*\b{n}\b.*\.md$", re.IGNORECASE),
        ]
        for p in md_files:
            for pat in pats:
                if pat.match(p.name):
                    return p
        return None

    if demo_key.startswith("66"):
        cand = []
        for p in md_files:
            if re.search(r"\b66\b", p.name):
                cand.append(p)
        cand = sorted(cand, key=lambda x: x.name.lower())
        if len(cand) < 2:
            return cand[0] if cand else None
        return cand[0] if demo_key.endswith("A") else cand[1]

    return None

def main() -> int:
    if not MAP_FILE.exists():
        print(f"Missing map file: {MAP_FILE}", file=sys.stderr)
        return 2
    if not INCOMING.exists():
        print("Missing incoming/ folder", file=sys.stderr)
        return 2

    demo_map = parse_simple_yaml(MAP_FILE)

    # Ensure package init files
    ensure_init(DEMOS_DIR)
    for cat in {v["category"] for v in demo_map.values()}:
        ensure_init(DEMOS_DIR / cat)

    moved = []
    missing = []

    for demo_key, spec in demo_map.items():
        cat = spec["category"]
        slug = spec["slug"]
        dest = DEMOS_DIR / cat / f"demo-{demo_key.lower()}-{slug}"
        dest.mkdir(parents=True, exist_ok=True)
        ensure_init(dest)

        py = find_py_for_demo(demo_key)
        md = find_readme_for_demo(demo_key)

        if py is None:
            missing.append((demo_key, "py"))
        else:
            (dest / "demo.py").write_text(py.read_text(encoding="utf-8", errors="replace"), encoding="utf-8")
            py.unlink()
            moved.append((demo_key, "py", str(dest / "demo.py")))

        if md is None:
            missing.append((demo_key, "md"))
        else:
            (dest / "README.md").write_text(md.read_text(encoding="utf-8", errors="replace"), encoding="utf-8")
            md.unlink()
            moved.append((demo_key, "md", str(dest / "README.md")))

    print("\nMoved:")
    for m in moved:
        print(" ", m)

    if missing:
        print("\nMissing (left in incoming):")
        for demo_key, kind in missing:
            print(f"  demo {demo_key}: missing {kind}")

    print("\nDone. Remaining in incoming:")
    for p in sorted(INCOMING.iterdir()):
        if p.is_file():
            print(" ", p.name)
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
